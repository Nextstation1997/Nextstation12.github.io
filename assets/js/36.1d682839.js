(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{197:function(a,t,s){"use strict";s.r(t);var e=s(0),r=Object(e.a)({},function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#集合","aria-hidden":"true"}},[a._v("#")]),a._v(" 集合")]),a._v(" "),s("p",[a._v("集合是一个在数学中的概念,在java中被引用,集合是“确定的一堆东西”，集合里的“东西”则称为元素。现代的集合一般被定义为：由一个或多个确定的元素所构成的整体.")]),a._v(" "),s("h2",{attrs:{id:"list-和-set-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#list-和-set-区别","aria-hidden":"true"}},[a._v("#")]),a._v(" List 和 Set 区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("List, Set 都是继承自 Collection 接口")])]),a._v(" "),s("li",[s("p",[a._v("List 特点：元素有放入顺序，元素可重复。Set 特点：元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在 set 中的位置是有该元素的 HashCode 决定的，其位置其实是固定的）")])]),a._v(" "),s("li",[s("p",[a._v("List 接口有三个实现类：LinkedList，ArrayList，Vector。Set 接口有两个实现类：HashSet(底层由 HashMap 实现)，LinkedHashSet")])])]),a._v(" "),s("h2",{attrs:{id:"list-和-map-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#list-和-map-区别","aria-hidden":"true"}},[a._v("#")]),a._v(" List 和 Map 区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("List 特点：元素有放入顺序，元素可重复")])]),a._v(" "),s("li",[s("p",[a._v("Map 特点：元素按键值对存储，无放入顺序")])]),a._v(" "),s("li",[s("p",[a._v("List 接口有三个实现类：LinkedList，ArrayList，Vector")])]),a._v(" "),s("li",[s("p",[a._v("LinkedList：底层基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢")])]),a._v(" "),s("li",[s("p",[a._v("Map 接口有三个实现类：HashMap，HashTable，LinkedHashMap")])]),a._v(" "),s("li",[s("p",[a._v("Map 相当于和 Collection 一个级别的；Map 集合存储键值对，且要求保持键的唯一性")])])]),a._v(" "),s("h2",{attrs:{id:"arraylist-与-linkedlist-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arraylist-与-linkedlist-区别","aria-hidden":"true"}},[a._v("#")]),a._v(" ArrayList 与 LinkedList 区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("存储结构上 ArrayList 底层使用数组进行元素的存储，LinkedList 使用双向链表作为存储结构")])]),a._v(" "),s("li",[s("p",[a._v("因为 Array 是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array 获取数据的时间复杂度是 O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。")])]),a._v(" "),s("li",[s("p",[a._v("在性能上 ArrayList 在存储大量元素时候的增删效率 平均低于 LinkedList，因为 ArrayList 在增删的是需要拷贝元素到新的数组，而 LinkedList 只需要将节点前后指针指向改变")])]),a._v(" "),s("li",[s("p",[a._v("类似于插入数据，删除数据时，LinkedList 也优于 ArrayList。")])]),a._v(" "),s("li",[s("p",[a._v("LinkedList 需要更多的内存，因为 ArrayList 的每个索引的位置是实际的数据，而 LinkedList 中的每个节点中存储的是实际的数据和前后节点的位置。")])]),a._v(" "),s("li",[s("p",[a._v("你的应用不会随机访问数据。因为如果你需要 LinkedList 中的第 n 个元素的时候，你需要从第一个元素顺序数到第 n 个数据，然后读取数据。")])]),a._v(" "),s("li",[s("p",[a._v("你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比 ArrayList 要快。")])])]),a._v(" "),s("h2",{attrs:{id:"arraylist-与-vector-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arraylist-与-vector-区别","aria-hidden":"true"}},[a._v("#")]),a._v(" ArrayList 与 Vector 区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("同步性：Vector 是线程安全的，也就是说是同步的 ，而 ArrayList 是线程不安全的，不是同步的。")])]),a._v(" "),s("li",[s("p",[a._v("数据增长：当需要增长时，Vector 默认增长为原来一倍 ，而 ArrayList 却是原来的 50% ，这样 ArrayList 就有利于节约内存空间。")])]),a._v(" "),s("li",[s("p",[a._v("性能: Vector 添加删除方法以及迭代器遍历的方法都是 synchronized 修饰的方法，在线程安全的情况下使用效率低于 ArrayList")])])]),a._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),s("p",[a._v("如果涉及到堆栈，队列等操作，应该考虑用 Vector，如果需要快速随机访问元素，应该使用 ArrayList")])]),a._v(" "),s("h2",{attrs:{id:"hashmap-和-hashtable-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-和-hashtable-的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" HashMap 和 HashTable 的区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("HashMap 几乎可以等价于 HashTable，除了 HashMap 是非 synchronized 的，并可以接受 null(HashMap 可以接受为 null 的键值 (key) 和值 (value)，而 HashTable 则不行)。")])]),a._v(" "),s("li",[s("p",[a._v("HashMap 是非 synchronized，而 HashTable 是 synchronized，这意味着 HashTable 是线程安全的，多个线程可以共享一个 HashTable；而如果没有正确的同步的话，多个线程是不能共享 HashMap 的。Java 5 提供了 ConcurrentHashMap，它是 HashTable 的替代，比 HashTable 的扩展性更好。")])]),a._v(" "),s("li",[s("p",[a._v("另一个区别是 HashMap 的迭代器 (Iterator) 是 fail-fast 迭代器，而 HashTable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），将会抛出 ConcurrentModificationException，但迭代器本身的 remove() 方法移除元素则不会抛出 ConcurrentModificationException 异常。但这并不是一个一定发生的行为，要看 JVM。这条同样也是 Enumeration 和 Iterator 的区别。")])]),a._v(" "),s("li",[s("p",[a._v("由于 HashTable 是线程安全的也是 synchronized，所以在单线程环境下它比 HashMap 要慢。如果你不需要同步，只需要单一线程，那么使用 HashMap 性能要好过 HashTable。")])]),a._v(" "),s("li",[s("p",[a._v("HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。")])])]),a._v(" "),s("h2",{attrs:{id:"hashset-和-hashmap-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashset-和-hashmap-区别","aria-hidden":"true"}},[a._v("#")]),a._v(" HashSet 和 HashMap 区别")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("HashMap")]),a._v(" "),s("th",[a._v("HashSet")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[a._v("HashMap 实现了 Map 接口")]),a._v(" "),s("td",[a._v("HashSet 实现了 Set 接口")])]),a._v(" "),s("tr",[s("td",[a._v("HashMap 储存键值对")]),a._v(" "),s("td",[a._v("HashSet 仅仅存储对象")])]),a._v(" "),s("tr",[s("td",[a._v("使用 put() 方法将元素放入 map 中")]),a._v(" "),s("td",[a._v("使用 add() 方法将元素放入 set 中")])]),a._v(" "),s("tr",[s("td",[a._v("HashMap 中使用键对象来计算 hashcode 值")]),a._v(" "),s("td",[a._v("HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以 equals() 方法用来判断对象的相等性，如果两个对象不同的话，那么返回 false")])]),a._v(" "),s("tr",[s("td",[a._v("HashMap 比较快，因为是使用唯一的键来获取对象")]),a._v(" "),s("td",[a._v("HashSet 较 HashMap 来说比较慢")])])])]),a._v(" "),s("h2",{attrs:{id:"hashmap-和-concurrenthashmap-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-和-concurrenthashmap-的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" HashMap 和 ConcurrentHashMap 的区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("ConcurrentHashMap 对整个桶数组进行了分段，而 HashMap 则没有")])]),a._v(" "),s("li",[s("p",[a._v("ConcurrentHashMap 在每一个分段上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好，而 HashMap 没有锁机制，不是线程安全的")])])]),a._v(" "),s("h2",{attrs:{id:"hashmap-的工作原理-jdk-1-8后做了哪些优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-的工作原理-jdk-1-8后做了哪些优化","aria-hidden":"true"}},[a._v("#")]),a._v(" HashMap 的工作原理 JDK 1.8后做了哪些优化")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("HashMap 基于 hashing 原理，我们通过 put() 和 get() 方法储存和获取对象。当我们将键值对传递给 put() 方法时，它调用键对象的 hashCode() 方法来计算 hashcode，让后找到 bucket 位置来储存值对象。当获取对象时，通过键对象的 equals() 方法找到正确的键值对，然后返回值对象。HashMap 使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap 在每个链表节点中储存键值对对象。")])]),a._v(" "),s("li",[s("p",[a._v("JDK 1.7 HashMap 底层采用单链表 + 数组的存储结构存储元素（键值对）。JDK1.8之后 HashMap 在同一哈希桶中节点数量（单链表长度）超过 8之后会使用 红黑树替换单链表来提高效率")])])]),a._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[a._v("什么是(hashing)哈希算法？")]),a._v(" "),s("p",[a._v("哈希算法又叫散列算法，是将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。它的原理其实很简单，就是把一段交易信息转换成一个固定长度的字符串。")]),a._v(" "),s("p",[a._v("这串字符串具有一些特点：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("信息相同，字符串也相同。")])]),a._v(" "),s("li",[s("p",[a._v("信息相似不会影响字符串相同。")])]),a._v(" "),s("li",[s("p",[a._v("可以生成无数的信息，但是字符串的种类是一定的，所以是不可逆的。")])])])]),a._v(" "),s("h2",{attrs:{id:"concurrenthashmap-的工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-的工作原理","aria-hidden":"true"}},[a._v("#")]),a._v(" ConcurrentHashMap 的工作原理")]),a._v(" "),s("ul",[s("li",[a._v('ConcurrentHashMap 采用了非常精妙的"分段锁"策略，ConcurrentHashMap 的主干是个 Segment 数组。Segment 继承了 ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在 ConcurrentHashMap，一个 Segment 就是一个子哈希表，Segment 里维护了一个 HashEntry 数组，并发环境下，对于不同 Segment 的数据进行操作是不用考虑锁竞争的。')])])])},[],!1,null,null,null);t.default=r.exports}}]);